---
title: 力扣Hot100
description: 力扣hot100的笔记
published: 2024-11-13
tags:
  - duffy
category: Others
---

## 001 两数之和

### 题目概述

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** _`target`_  的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

### 思路

#### 方法1 暴力
很直接的搜索，第一次遍历数组找到`nums[i]`，第二次是找`target-nuns[i]`，暴力搜索。

时间复杂度$O(n^2)$ ，空间复杂度$O(1)$ 

#### 方法2 哈希表
这个问题归根到底是通过`num[i]`来找到是否有`target-nuns[i]`这个值，在方法1中，我们是通过遍历来寻找这个值，那我们也许就考虑到使用一个数据结构来加快搜索，哈希表！所以方法2是通过哈希表来加速方法1中的暴力。

时间复杂度$O(n)$ ，空间复杂度$O(n)$ 
#### 方法3 双指针
如果假设这个数组是有序的，那么我们就可以设置两个指针，一个从头开始，一个从末尾往前找，最终只需要遍历一次数组就可以找到。

但是当前数组是无序的，没有那么好的条件。

所以我们可以考虑通过创建副本数组，然后对其排序，用于查找对应值在原数组的位置。

时间复杂度$O(nlogn)$ ，空间复杂度$O(n)$ 


## 002 字母异位词分组
### 题目概述
49题

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。

**示例:**

**输入:** `strs = ["eat", "tea", "tan", "ate", "nat", "bat"]`

**输出:** `[["bat"],["nat","tan"],["ate","eat","tea"]]`

### 思路

字母异位词，也就是说组成单词的字母相同。那我们可以考虑有几个不同的字母，以及对应字母出现的次数。比如eat和tea，其中字母组成和各字母个数是相同的，所以我们可以放到一起。

那问题就转换为找相同字母组成与各字母个数的字符串集。

首先我们先看如何表示一个字符串的字母组成和各字母个数，这是划分不同类的判别标准。
我们可以考虑转换顺序把所有的字符串中字母按照同样的顺序排列，比如把其中的字母按照字母序排列。比如eat可以变为aet，而此时的tea也可以变为aet，判别相同，然后划分为同一类。
然后根据字符串的表示来分类。

这里我们用到了查找，即根据当前的判别标准来查找其他的是否有相同的类别。所以可以采用哈希表，即为一一对应关系，类别特征对应有相同特征的字符串集合。

#### 方法1 按字母序排列

把字符串中的字符重新排列，得到判别标准。

比如`tea`，得到`aet`；比如`basste`，得到`abetss`；然后插入哈希表，如果不存在则创建映射关系，存在则插入映射的字符串集数组中。

#### 方法2 按字母序分类以及数量排列

每个字符串创建一个String，其中为字母和出现次数的排列。比如`basste`，可以化为`a1b1e1t1s2`，这个标准对于任意不同字母排列的字符串是唯一的。然后插入哈希表，如果不存在则创建映射关系，存在则插入映射的字符串集数组中。

### 要点
关键点是找到同类字符集和不同字符集的特征，然后根据特征对其分类。


## 003 最长连续序列
### 题目概述
相当于


## 004 移动零
### 题目概述
把数组中的零都移到数组末尾，其余数字相对顺序不变。要求原地处理数组。

### 思路
把零都移到末尾，关键是先找到零的位置，然后进行移动，移动同时需要确认移动的位置以及方式。

首先找到零的位置，需求是移到数组末尾，那么我们可以从左到右一次寻找，或者从右往左依次寻找，我感觉从两侧开始找都可以的，但是按照一般经验来说，从左往右更符合常理。

首先从右往左定位第一个零的位置，此时我们找到了需要移动的零的位置，接下来我们需要找到这个零应该往后移到哪里。

由于要求其余数字相对位置不变，选择选定的零后的第一个非零元素是最合适的。

所以我们就可以考虑使用双指针，一个指向零，一个指向零后第一个非零元素。

所以本题考虑使用双指针。

### 要点
理清题目要求，首先找到零，然后找移动的位置，这两个分别代表一个指针指向的内容。

## 005 能装最多水的容器
### 题目概述
给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

举例
对于数组`[1,8,6,2,5,4,8,3,7]`
输出`49` 
### 思路

考虑这个问题，我们需要确定两个索引值，即left、right，即求$|right-left| * |height[left] - height[right]|$的最大值。

比如一个0开始、一个从最后一个值开始判断。

那么从

## 006 三数之和
### 题目概述
给定一个数组，找出其中三个和为零的数的集合。返回数的集合，不包含重复解。

### 思路
想象一下，如果我们用三层for循环遍历，那就是需要$O(n^3)$时间复杂度，并且我们还需要去重，时间复杂度会更高！

如果我们假定结果 a+b+c=0，那么不去重就可能遇到这种情况，$[a,b,c] [b,a,c] [c,a,b]$，这三个其实是同一个答案。那么我们如果事先假定$a\leq b\leq c$呢，那么我们得到的结果就不会重复。并且题目中并没有让我们给出下标，而是数的集合，因此我们可以先对数组进行排序。

对数组进行排序后，我们就得到了从小到大的一维数组。然后我们可以进行最初的for循环，此时我们可以不用担心重复过多的情况！

我们需要在对数组进行遍历的情况下，对已经有重复值的索引进行跳过，比如对于排序好的数组$[-1,-1,0,1,2,3]$，在i,j,k遍历中，i首次遍历到索引0的-1处，j,k在后方找到对应结果$[-1,-1,2] [-1,0,1]$，然后i再遍历到索引1的-1处，此时能找到的结果必定是在索引0处找到的结果的子集，因为i的取值不变的情况下，j,k的取值区间变小，因此结果是更少的！

同样如果在找到对应的i,j,k时，j,k对应的下一个取值处的值与之前相同，那么肯定得到的结果和上一步相同。因此我们在这个地方也要处理。


## 008 无重复字符的最长子串
### 题目概述

寻找一个子串，其中无重复字符，求其长度。

比如`"abacbade"`，可以得到

**a**

**ab**

a**ba**

a**bac**

ab**acb**

aba**cba**

aba**cbad**

aba**cbade**

其中加深色的子串中无重复字符。

### 思路

我们可以看到我们从左往右扫描的过程，一直在维护一个区间，这个区间是连续的，我们每次往后扩展的过程中，我们发现，当遇到一个尚未存在的词，我们可以往后增加区间长度，如果我们遇到一个已经存在的词，我们就需要把区间的左端点往后移，直到符合要求。

这里我们需要考虑两个东西：
1.区间范围的定义 右进左出
2.如何判断是否重复

我们从1中可以看到，这不就是队列吗？一头进，一头出。而2中我们可以看到，这就是和Set数据结构很类似，即不重复元素的集合。

而这个方法有一个大家更常叫的名字：**滑动窗口**。即我们维护一个区间，这个区间范围随着我们处理，区间的右端点不断右移，左端点根据情况右移，一般而言符合情况的数就在区间范围内。（说到底就是滑动窗口是满足最后一个节点是右端点并且符合题意的最大序列）

因此我们在往后移动的过程中，每次发现一个新字母，就观察其是否已经存在于窗口范围内，如果不存在，符合情况，则窗口向右扩展；如果存在，那么不符合情况，因此我们需要依次从窗口左端右移，去除元素，直至发现那个存在的元素，然后把这个元素去掉即左端再次右移，最终把新元素添加入窗口。

最终我们在不断右移的过程中，发现最长的序列长度。

## 009 和为k的子数组
### 题目概述
对于某数组，求其中和为k的子数组个数，比如`[1,-1,0]`，`k = 0`，那么存在`[-1,1]、[1,1,0]`，这两种情况。

### 思路

和为k，如果我们暴力求解，需要$O(n^3)$的复杂度，遍历区间范围，然后再对范围内的数组进行求和。遍历范围$O(n^2)$，求和$O(n)$，结合便是$O(n^3)$。

对于暴力方法中的步骤，我们可以先优化求和方法，即我们并不需要每次都遍历数组全部数字，我们可以考虑使用前缀合方法来求和。

比如对于原始数组`nums`，我们求的`pre`前缀合数组，那么我们需要求第`i`到第`j`位的子数组和，我们只需要计算`pre[j] - pre[i-1]`即可得到。

那么问题就转换为，遍历`i`、`j`，然后找到符合`pre[j] - pre[i-1] == k`的结果个数。

时间复杂度降了一个等级。

如果继续思考，外层遍历i，内层遍历j，即我们需要在`[i,j]`范围中找到满足题意的子数组个数，那么我们就是根据pre[j]，来找到一个pre使得`pre[j] - pre == k`，所以问题又转化为查找数组中是否存在`pre[j] - k`。所以呢，我们可以继续使用哈希查找来再次优化。

即我们把前缀数组放入哈希表，但是存在一个问题，如果有多个pre元素相同，那么我们应该如何表示呢？所以在这里我们不能使用HashSet，我们需要使用HashMap来表示存在元素重复的情况，key对应的是pre值，value对应的存在个数。如果存在多个，那么我们可以直接加对应个数。

由于元素存在顺序关系，即`pre[j] - pre[i]`表示前缀合需要满足`j>=i>=0`，所以我们可以在遍历的过程中先检查再把元素加入哈希表。如果`pre==k`，那么我们也需要事先把`(0,1)`加入map中。






